#!/bin/bash
#
# Script for simulating dynamic network conditions
# Probably works best if ran in the same directory as the script
# TODO:
#   - Limiting bandwidth
#
######################

display_help () {
  printf "%b \n" "\033[1m"NAME"\033[0m"
  printf "\t%s - Script to simulate network conditions of system on the edge \n" $(basename $0)
  printf "\t(probably works best if ran in the same directory as the script)"
  printf "\n%b \n" "\033[1m"SYNOPSIS"\033[0m"
  printf "\t%b %b %b %b %b\n" "\033[1m""$(basename $0) -N=""\033[0m""[\033[4m"ARGUMENT"\033[0m]" \
                         "\033[1m"" -n=""\"\033[0m""[\033[4m"ARGUMENT"\033[0m]\"" \
                         "\033[1m"" -t=""\033[0m""[\033[4m"ARGUMENT"\033[0m]" \
                         "\033[1m"" -l=""\033[0m""[\033[4m"ARGUMENT"\033[0m]" \
                         "\033[1m"" -r=""\033[0m""[\033[4m"ARGUMENT"\033[0m]" 
  printf "\t%b \n" "\033[1m""$(basename $0) -h""\033[0m"
  printf "\n%b \n" "\033[1m"DESCRIPTION"\033[0m"
  printf "\t This script is used to simulate network conditions of systems on the edge. Such as: \n"
  printf "\t\t %b Adding a delay on a specific link between nodes that increases at some rate %b to simulate a node getting further away\n" "\033[1m""-""\033[0m" "\033[1m""l""\033[0m"
  printf "\t\t %b Decreasing bandwidth to simulate constrained network conditions on the edge\n" "\033[1m""-""\033[0m"
  printf "\t\t %b Simulating a node leaving and re-joining the cluster at varying speeds\n" "\033[1m""-""\033[0m"
  printf "\n"
  printf "\t %b, %b \n\t\t Number of nodes to add delay to at once.  %b should be some integer less than the amount of space separated IPs in %b \n\n" \
                                                                                                         "\033[1m""-N=""\033[0m""\033[4m"NUM_NODES"\033[0m" \
                                                                                                         "\033[1m""--num_nodes=""\033[0m""\033[4m"NUM_NODES"\033[0m"   \
                                                                                                         "\033[4m"NUM_NODES"\033[0m" \
                                                                                                         "\033[4m"IPs"\033[0m" 

  printf "\t %b, %b \n\t\t List of node %b to add a delay onto. multiple node %b need to be quoted \n\n" "\033[1m""-n=""\033[0m""\"\033[4m"IPs"\033[0m\"" \
                                                                                                         "\033[1m""--nodes=""\033[0m""\"\033[4m"IPs"\033[0m\""  \
                                                                                                         "\033[1m"IPs"\033[0m" \
                                                                                                         "\033[1m"IPs"\033[0m" 

  printf "\t %b, %b \n\t\t Integer value of how many intervals of 5s that a delay should be added \n\n" "\033[1m""-t=""\033[0m""\033[4m"NUM_INTERVALS"\033[0m" \
                                                                                                        "\033[1m""--time_intervals=""\033[0m""\033[4m"NUM_INTERVALS"\033[0m"

  printf "\t %b, %b \n\t\t Float value of how much delay should increase per time interval. \n\t\t All added delays are automatically removed after the specifed number of time intervals \n\n" \
                                                                                                         "\033[1m""-l=""\033[0m""\033[4m"LATENCY_DELTA"\033[0m" \
                                                                                                         "\033[1m""--latency_delta=""\033[0m""\033[4m"LATENCY_DELTA"\033[0m"

  printf "\t %b, %b \n\t\t Optional integer value of after %b time intervals the delay should start to decrease. \n\t\t The return will evenly decrease the delay across the remaining time intervals specified in %b. \n\t\t This value MUST be strictly less than the amount of intervals. \n\n" \
                                                                                                         "\033[1m""-r=""\033[0m""\033[4m"INTERVAL_RETURN"\033[0m"  \
                                                                                                         "\033[1m""--time_return=""\033[0m""\033[4m"INTERVAL_RETURN"\033[0m" \
                                                                                                         "\033[0m""\033[4m"INTERVAL_RETURN"\033[0m" \
                                                                                                         "\033[0m""\033[1m"-t"\033[0m"
  printf "\t %b, %b \n\t\t (optional) The path relative to this script to a client exectuable \n\n" \
                                                                                                         "\033[1m""-c=""\033[0m""\033[4m"CLIENT"\033[0m" \
                                                                                                         "\033[1m""--client=""\033[0m""\033[4m"CLIENT"\033[0m"

  printf "\t %b, %b \n\t\t (required if '-c' or '--client' is provided)  The node %b to run the client executable on. \n\t\t Same quoting rules from '-n' apply here \n\n" \
                                                                                                         "\033[1m""-s=""\033[0m""\033[4m"IPs"\033[0m" \
                                                                                                         "\033[1m""--client_nodes=""\033[0m""\033[4m"IPs"\033[0m" \
                                                                                                         "\033[1m"IPs"\033[0m" 

  printf "\t %b, %b \n\t\t (optional if '-c' or '--client' is provided) Optional arguments to pass into the client executable when it is ran \n\n" \
                                                                                                         "\033[1m""-a=""\033[0m""\033[4m"CLIENT_ARGS"\033[0m" \
                                                                                                         "\033[1m""--client_args=""\033[0m""\033[4m"CLIENT_ARGS"\033[0m"

  printf "\t %b, %b \n\t\t Optional argument to output L1 Latency (ping latency) between nodes. \n\t\t This value is the other nodes of the protocol that aren't having added delay \n\n" \
                                                                                                         "\033[1m""-o=""\033[0m""\033[4m"OTHER_NODES"\033[0m" \
                                                                                                         "\033[1m""--other_nodes=""\033[0m""\033[4m"OTHER_NODES"\033[0m"

  printf "\t %b,\tDisplay this help message again \n\n" "\033[1m""-h""\033[0m"
  printf "\n%b \n" "\033[1m"EXAMPLES"\033[0m"
  printf "\t%b\n" "\033[1m""Adding delay to a node:""\033[0m"
  printf "\t\t./sim_net_conds -N=1 -n=node1 -t=15 -l=0.1 -r=10\n\n"
  printf "\t\t./sim_net_conds --num_nodes=1 --nodes=node1 --time_intervals=15 --latency_delta=0.1 --time_return=10\n\n"
  printf "\t\t./sim_net_conds -N=3 -n=\"node1 node2 node3\" -t=15 -l=0.1 -r=10\n\n"
  printf "\t\t./sim_net_conds -N=3 -n=\"node1 node2 node3\" -t=15 -l=0.1 -r=10 -c=\"../bin/client\" -s=\"node1\" -a=\"-maddr=node0\" \n\n"
  printf "\t\t./sim_net_conds -N=1 -n=\"node1\" -t=15 -l=0.1 -r=10 -c=\"bin/client\" -s=\"node1\" -a=\"-maddr=node0\"  -o=\"node2 node3\" \n\n"
  printf "\t%b\n" "\033[1m""Displaying this help message again:""\033[0m"
  printf "\t\t./sim_net_conds -h\n\n"
}


for i in "$@"; do
    case $i in
        ## Number of nodes to delay
        -N=*|--num_nodes=*)
            NUMNODES="${i#*=}"
            shift
            ;;
        ## Get list of nodes, must be in quotes:  "node1 node2 ..."
        -n=*|--nodes=*)
            NODES="${i#*=}"
            shift # Past argument=value
            ;;
        ## how many time intervals of 5ms to run
        -t=*|--time_intervalS=*)
            TIMEINTERVALS="${i#*=}"
            shift # Past argument=value
            ;;
        ## Increase in latency per time interval
        -l=*|--latency_delta=*)
            LATENCYDELTA="${i#*=}"
            shift # Past argument=value
            ;;
        ## How many time intervals until the node starts coming back
        -r=*|--time_return=*)
            TIMERETURN="${i#*=}"
            shift # Past argument=value
            ;;
        ## Client executable 
        -c=*|--client=*)
            CLIENT="${i#*=}"
            shift
            ;;
        ## The nodes in which to run the client executable
        -s=*|--client_nodes=*)
            CLIENTNODES="${i#*=}"
            shift
            ;;
        ## (OPTIONAL) Argmuents to be passed to the client when it is ran
        -a=*|--client_args=*)
            CLIENTARGS="${i#*=}"
            shift
            ;;
        -o=*|--other_nodes=*)
          OTHERNODES="${i#*=}"
          shift
          ;;
        -d=*|--enable_des=*)
          ENABLEDES="${i#*=}"
          shift
          ;;
        -h*|--help*)
          display_help
          exit 1
          ;;
        -*|--*)
            echo "Unknown option $i"
            exit 1
            ;;
        *)
            ;;
    esac
done

auto_client=false

if [ -n "$CLIENT" ] && [ -n "$CLIENTNODES" ] ; then
  read -a client_nodes_arr <<< "$CLIENTNODES" 
  client_name=$(basename ${CLIENT})
  auto_client=true
elif [ -n "$CLIENT" ] || [ -n "$CLIENTNODES" ] ; then
  echo "Incorrect Arguments!"
  echo "If you provide a client executable you must provide the nodes to run it on!"
  echo "See -h for usage."
  exit 1
fi

if [ "$NUMNODES" == "" ] || [ "$NODES" == "" ] || [ "$TIMEINTERVALS" == "" ] || [ "$LATENCYDELTA" == "" ]  ; then
  echo "Incorrect number of args!"
  echo "Please provide all required arguments."
  echo "See -h for usage."
  exit 2
fi

## Exp timestamp, this is used to identify experiments
expid=$(date +%s)
echo "Exp ID: $expid"

## Dir for results
mkdir -p "$expid"_results

## 5s
TIMEINTERVAL=5
read -a nodes_arr <<< "$NODES"

if [ -n "$OTHERNODES" ] ; then
  read -a other_nodes_arr <<< "$OTHERNODES"
fi


## DEBUG
#echo $NODES
#echo $TIMEINTERVALS
#echo $LATENCYDELTA
#echo $TIMERETURN
#echo $NUMNODES
#for i in ${nodes_arr[@]} ; do echo $i; done
#for i in $(seq 0 $(expr $NUMNODES - 1) ) ; do echo ${nodes_arr[$i]} ; done
#for i in ${client_nodes_arr[@]} ; do echo $i; done
#exit
## END DEBUG

continue_delay () {
    return $(echo "$currentinterval >= $TIMEINTERVALS" | bc -l )
}

get_ip_and_device () {
    ## Gets the ip of the node running the script so the node we want can use it to find its interface
    my_ip=$(ifconfig | grep inet | awk 'FNR == 3 {print $2}')
    ## In awk FNR is the a variable that represents the number of records/lines to read
    ip=$(ping -c 1 $1 | awk 'FNR == 1 {print $3}' | sed -e 's/^.//' -e 's/.$//')
    ## Network interface is
    #dev=$(ip route get $my_ip | awk 'FNR == 1 {print $3}')
    dev=$(ssh -T -o StrictHostKeyChecking=no $ip "ip route get $my_ip | awk 'FNR == 1 {print \$3}'")
}

run_client () {
    res_file="$expid"_results/"$expid"_"$currentinterval".dat
    replicaId=0
    for client_node in ${client_nodes_arr[@]} ; do
      get_ip_and_device $client_node
      client_output=$(ssh -T -o StrictHostKeyChecking=no $ip "export REPLICAID=$replicaId ; ./$client_name $CLIENTARGS" | grep 'Latency' | awk '{print $2}' \
        >> "$expid"_results/"$expid"_"$currentinterval".dat )
      ((replicaId++))
    done
    sort -n -o "$res_file" "$res_file"
    n=$(wc -l "$res_file" | awk '{print $1}')
    median_row=$(echo "$n / 2" | bc -l)
    median_latency=$(cat "$res_file" | awk  "FNR == $median_row {print \$1}")
    echo "L3 Median Latency: $median_latency ms"
    tail_row=$(python -c "import math; print(math.ceil(0.99 * $n) -1 )")
    tail_latency=$(cat "$res_file" | awk "FNR == $tail_row {print \$1}")
    echo "L3 Tail Latency: $tail_latency ms"
    
}

get_ping_latency () {
  for node in ${nodes_arr[@]} ; do
    get_ip_and_device $node
    nodeip=$ip
    for other_node in ${other_nodes_arr[@]} ; do
      if [ "$node" != "$other_node" ] ; then
        get_ip_and_device $other_node
        ping_latency=$(ssh -T -o StrictHostKeyChecking=no $nodeip "ping -c 1 $ip" | awk 'FNR == 2 {print $7}' | cut -d = -f 2 | sed 's/$/ms/')
        echo "$node L1 Latency to $other_node : $ping_latency" 
      fi
    done
  done
}

## SCP the client to the client nodes
if [ $auto_client ] ; then
  for client_node in ${client_nodes_arr[@]} ; do
    get_ip_and_device $client_node
    scp `pwd`/$CLIENT $ip: > /dev/null
  done
fi


currentinterval=0
## Run a baseline
if [ $auto_client ] ; then
  echo "Baseline without additional network delay."
  get_ping_latency
  run_client
  echo ""
fi

## Starts at 1 for multiplication reasons
## And because conceptually the first delay is the first interval
currentinterval=1
## Delay is interval * latencydelta
delay=$(echo "$currentinterval * $LATENCYDELTA" | bc -l )
echo "Interval: $currentinterval"
echo "Current Additional Network Delay is: $delay ms"
for i in $(seq 0 $(expr $NUMNODES - 1)) ; do
  get_ip_and_device ${nodes_arr[$i]}
  ## The following `iptables` and `tc filter` commands ensure that ssh traffic isn't slowed down.
  ## This ensures that the delay added by this script doesn't slow down the script
  ## If this wasn't here the script would have to wait the current delay to update the delay due to ssh connection 
  ## This should also fix the issue with ssh timing out after incuring a several second delay due to TCP 
  ssh -T -o StrictHostKeyChecking=no $ip "\
sudo tc qdisc add dev $dev root handle 1: prio bands 3 ;\
sudo tc qdisc add dev $dev parent 1:2 handle 20: netem delay ${delay}ms ;\
sudo iptables -t mangle -A OUTPUT -p tcp --sport 22 -j MARK --set-mark 22 ;\
sudo tc filter add dev $dev parent 1:0 protocol ip handle 22 fw flowid 1:1 ;\
" 

done

if [ $auto_client ] ; then
  get_ping_latency
  run_client
  echo ""
fi
((currentinterval++))

while continue_delay
do

 

  sleep $TIMEINTERVAL

  if [[ -n $TIMERETURN ]] && [ $currentinterval -ge $TIMERETURN ] ; then
    ## Progressively backing off delay
    ## `RI - [ (RI / (TI - RI)) * (CI - RI) ]` Should give a progressive decrease in delay between RI and TI and will end with a delay of 0
    delay=$(echo "$LATENCYDELTA * ($TIMERETURN - (($TIMERETURN / ($TIMEINTERVALS - $TIMERETURN)) * ($currentinterval - $TIMERETURN)))" | bc -l )
  else
    delay=$(echo "$currentinterval * $LATENCYDELTA" | bc -l )
  fi

  echo "Interval: $currentinterval"
  echo "Current Additional Network Delay is: $delay ms"
  for i in $(seq 0 $(expr $NUMNODES - 1)) ; do
    get_ip_and_device ${nodes_arr[$i]}
    ssh -T -o StrictHostKeyChecking=no $ip "sudo tc qdisc change dev $dev parent 1:2 handle 20: netem delay ${delay}ms"
  done

  if [ $auto_client ] ; then
    get_ping_latency
    run_client
    echo ""
  fi

  ((currentinterval++))
done

echo "Resetting Network Changes..."
for i in $(seq 0 $(expr $NUMNODES - 1)) ; do
 get_ip_and_device ${nodes_arr[$i]}
 ssh -T -o StrictHostKeyChecking=no $ip "sudo tc qdisc del dev $dev root ; sudo iptables -t mangle -F " 2>&1

done



